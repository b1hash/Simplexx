name: Build & Test Simplexx

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

jobs:
  build-windows-client:
    name: Build Windows Client
    runs-on: self-hosted
    strategy:
      matrix:
        configuration: [Release]
        platform: [x64, x86]
        include:
          - platform: x64
            msvc_arch: x64
            msbuild_platform: x64
          - platform: x86
            msvc_arch: x86
            msbuild_platform: x86
    env:
      CONFIGURATION: ${{ matrix.configuration }}
      PLATFORM: ${{ matrix.platform }}
      MSBUILD_PLATFORM: ${{ matrix.msbuild_platform }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
        timeout-minutes: 10
        continue-on-error: false

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            external/
            build_deps/
          key: deps-${{ runner.os }}-${{ hashFiles('**/cpp-ci.yml') }}
          restore-keys: |
            deps-${{ runner.os }}-
            deps-

      - name: Ensure Visual Studio Build Tools (only on self-hosted)
        if: runner.os == 'Windows'
        run: |
          try {
            $chocoCmd = Get-Command choco -ErrorAction SilentlyContinue
            if ($chocoCmd) {
              Write-Host "Checking for Visual Studio Build Tools..."
              $pkg = choco list --local-only | Select-String "visualstudio2019buildtools"
              if (-not $pkg) {
                Write-Host "Installing Visual Studio Build Tools..."
                choco install visualstudio2019buildtools --package-parameters `
                  "--add Microsoft.VisualStudio.Component.VC.Tools.x86.x64 `
                   --add Microsoft.VisualStudio.Component.Windows10SDK.19041 `
                   --add Microsoft.VisualStudio.Component.VC.ATLMFC `
                   --add Microsoft.VisualStudio.Component.VC.v142.x86.x64 `
                   --add Microsoft.VisualStudio.Component.VC.ATLMFC.v142.x86.x64 `
                   --includeRecommended --includeOptional --quiet --norestart" -y
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "Visual Studio Build Tools installed successfully"
                } else {
                  Write-Host "Failed to install Visual Studio Build Tools"
                }
              } else {
                Write-Host "Visual Studio Build Tools already installed"
              }
            } else {
              Write-Host "Chocolatey not available, skipping Visual Studio installation"
            }
          } catch {
            Write-Host "Error during Visual Studio setup: $($_.Exception.Message)"
          }

      - name: Setup MSVC dev cmd
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.msvc_arch }}

      - name: Download zstd source
        run: |
          try {
            $zstdUrl = "https://github.com/facebook/zstd/releases/download/v1.5.5/zstd-v1.5.5-win64.zip"
            $zstdDir = "external\zstd"

            Write-Host "Creating directory: $zstdDir"
            if (!(Test-Path $zstdDir)) {
              New-Item -ItemType Directory -Force -Path $zstdDir | Out-Null
            }

            Write-Host "Downloading zstd from: $zstdUrl"
            [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
            Invoke-WebRequest -Uri $zstdUrl -OutFile "$zstdDir\zstd.zip" -UseBasicParsing

            Write-Host "Extracting archive..."
            Add-Type -AssemblyName System.IO.Compression.FileSystem
            [System.IO.Compression.ZipFile]::ExtractToDirectory("$zstdDir\zstd.zip", $zstdDir)

            Write-Host "zstd directory contents:"
            Get-ChildItem -Recurse $zstdDir | ForEach-Object { Write-Host "  $($_.FullName)" }
          } catch {
            Write-Host "Error downloading zstd: $($_.Exception.Message)"
            throw
          }

      - name: Download and build dependencies
        run: |
          try {
            $depsDir = "external"
            $buildDir = "build_deps"

            # Check if dependencies are already cached
            $cacheHit = Test-Path "$depsDir\zstd" -and (Test-Path "$buildDir\zlib" -or (Get-ChildItem "$depsDir\*.zip" -ErrorAction SilentlyContinue).Count -gt 0)

            if ($cacheHit) {
              Write-Host "Dependencies cache hit - skipping download and build"
              Write-Host "Cached directories:"
              if (Test-Path $depsDir) { Get-ChildItem $depsDir | ForEach-Object { Write-Host "  $($_.FullName)" } }
              if (Test-Path $buildDir) { Get-ChildItem $buildDir | ForEach-Object { Write-Host "  $($_.FullName)" } }
              return
            }

            Write-Host "Dependencies cache miss - downloading and building..."

            # Create directories
            Write-Host "Creating directories..."
            if (!(Test-Path $depsDir)) { New-Item -ItemType Directory -Force -Path $depsDir | Out-Null }
            if (!(Test-Path $buildDir)) { New-Item -ItemType Directory -Force -Path $buildDir | Out-Null }

            # Download and build zlib v1.3.1
            Write-Host "Downloading and building zlib v1.3.1..."
            $zlibUrl = "https://github.com/madler/zlib/archive/refs/tags/v1.3.1.zip"
            $zlibDir = "$depsDir\zlib-1.3.1"
            Invoke-WebRequest -Uri $zlibUrl -OutFile "$depsDir\zlib.zip" -UseBasicParsing
            [System.IO.Compression.ZipFile]::ExtractToDirectory("$depsDir\zlib.zip", $depsDir)
            Push-Location $zlibDir
            cmake -B build -S . -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$buildDir\zlib"
            cmake --build build --config Release --target install
            Pop-Location

            # Download and build x264 v0.164.3194
            Write-Host "Downloading and building x264..."
            $x264Url = "https://code.videolan.org/videolan/x264/-/archive/stable/x264-stable.tar.gz"
            $x264Dir = "$depsDir\x264"
            Invoke-WebRequest -Uri $x264Url -OutFile "$depsDir\x264.tar.gz" -UseBasicParsing
            # Extract tar.gz (simplified - may need 7zip or similar)
            Write-Host "x264 downloaded - manual build may be required"

            # Download libyuv v190
            Write-Host "Downloading libyuv v190..."
            try {
              $libyuvUrl = "https://github.com/lemenkov/libyuv/archive/refs/tags/v190.tar.gz"
              $libyuvDir = "$depsDir\libyuv"
              Invoke-WebRequest -Uri $libyuvUrl -OutFile "$depsDir\libyuv.tar.gz" -UseBasicParsing
              Write-Host "libyuv downloaded successfully"
            } catch {
              Write-Host "Primary libyuv URL failed, trying alternative..."
              try {
                $libyuvUrl = "https://github.com/lemenkov/libyuv/archive/refs/tags/v190.zip"
                Invoke-WebRequest -Uri $libyuvUrl -OutFile "$depsDir\libyuv.zip" -UseBasicParsing
                Write-Host "libyuv downloaded successfully (zip format)"
              } catch {
                Write-Host "Warning: Failed to download libyuv from all sources"
              }
            }

            # Download ffmpeg 4.5.r104394
            Write-Host "Downloading ffmpeg..."
            $ffmpegUrl = "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip"
            $ffmpegDir = "$depsDir\ffmpeg"
            Invoke-WebRequest -Uri $ffmpegUrl -OutFile "$depsDir\ffmpeg.zip" -UseBasicParsing
            [System.IO.Compression.ZipFile]::ExtractToDirectory("$depsDir\ffmpeg.zip", $ffmpegDir)

            # Download jsoncpp v1.9.6
            Write-Host "Downloading and building jsoncpp v1.9.6..."
            $jsoncppUrl = "https://github.com/open-source-parsers/jsoncpp/archive/refs/tags/1.9.6.zip"
            $jsoncppDir = "$depsDir\jsoncpp-1.9.6"
            Invoke-WebRequest -Uri $jsoncppUrl -OutFile "$depsDir\jsoncpp.zip" -UseBasicParsing
            [System.IO.Compression.ZipFile]::ExtractToDirectory("$depsDir\jsoncpp.zip", $depsDir)
            Push-Location $jsoncppDir
            cmake -B build -S . -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$buildDir\jsoncpp" -DJSONCPP_WITH_TESTS=OFF
            cmake --build build --config Release --target install
            Pop-Location

            # Download jpeg v3.1.1
            Write-Host "Downloading and building jpeg v3.1.1..."
            $jpegUrl = "https://github.com/libjpeg-turbo/libjpeg-turbo/archive/refs/tags/3.1.1.zip"
            $jpegDir = "$depsDir\libjpeg-turbo-3.1.1"
            Invoke-WebRequest -Uri $jpegUrl -OutFile "$depsDir\jpeg.zip" -UseBasicParsing
            [System.IO.Compression.ZipFile]::ExtractToDirectory("$depsDir\jpeg.zip", $depsDir)
            Push-Location $jpegDir
            cmake -B build -S . -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX="$buildDir\jpeg"
            cmake --build build --config Release --target install
            Pop-Location

            # Download shrink v0.0.1
            Write-Host "Downloading shrink v0.0.1..."
            try {
              $shrinkUrl = "https://github.com/username/shrink/archive/refs/tags/v0.0.1.zip"
              $shrinkDir = "$depsDir\shrink-0.0.1"
              Invoke-WebRequest -Uri $shrinkUrl -OutFile "$depsDir\shrink.zip" -UseBasicParsing
              [System.IO.Compression.ZipFile]::ExtractToDirectory("$depsDir\shrink.zip", $depsDir)
              Write-Host "shrink downloaded successfully"
            } catch {
              Write-Host "Warning: Failed to download shrink - may need manual installation"
            }

            # Download HPSocket v6.0.3
            Write-Host "Downloading HPSocket v6.0.3..."
            $hpsocketUrl = "https://github.com/ldcsaa/HP-Socket/archive/refs/tags/v6.0.3.zip"
            $hpsocketDir = "$depsDir\HP-Socket-6.0.3"
            Invoke-WebRequest -Uri $hpsocketUrl -OutFile "$depsDir\hpsocket.zip" -UseBasicParsing
            [System.IO.Compression.ZipFile]::ExtractToDirectory("$depsDir\hpsocket.zip", $depsDir)

            # Download clip v1.11
            Write-Host "Downloading clip v1.11..."
            $clipUrl = "https://github.com/dacap/clip/archive/refs/tags/v1.11.zip"
            $clipDir = "$depsDir\clip-1.11"
            Invoke-WebRequest -Uri $clipUrl -OutFile "$depsDir\clip.zip" -UseBasicParsing
            [System.IO.Compression.ZipFile]::ExtractToDirectory("$depsDir\clip.zip", $depsDir)

            Write-Host "All dependencies downloaded. Build scripts may need to be run manually for some libraries."
          } catch {
            Write-Host "Error downloading dependencies: $($_.Exception.Message)"
            throw
          }

      - name: Verify dependency cache
        run: |
          Write-Host "Verifying cached dependencies..."
          $depsDir = "external"
          $buildDir = "build_deps"

          Write-Host "External dependencies:"
          if (Test-Path $depsDir) {
            Get-ChildItem $depsDir -Recurse | Where-Object { -not $_.PSIsContainer } | ForEach-Object {
              Write-Host "  $($_.FullName)"
            }
          }

          Write-Host "Built dependencies:"
          if (Test-Path $buildDir) {
            Get-ChildItem $buildDir -Recurse | Where-Object { -not $_.PSIsContainer } | ForEach-Object {
              Write-Host "  $($_.FullName)"
            }
          }

      - name: Setup CMake
        uses: lukka/get-cmake@latest

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v2

      - name: Build solution (2019Remote.sln)
        run: |
          try {
            Write-Host "Searching for solution file..."
            $sln = (Get-ChildItem -Recurse -Filter '2019Remote.sln' | Select-Object -First 1).FullName
            if (-not $sln) {
              throw "Solution file '2019Remote.sln' not found"
            }

            Write-Host "Building solution: $sln"
            Write-Host "Configuration: $env:CONFIGURATION"
            Write-Host "Platform: $env:MSBUILD_PLATFORM"
            Write-Host "Toolset: v142 (Visual Studio 2019)"
            Write-Host "Using MFC: Yes"

            # Build include and library paths
            $workspaceRoot = Get-Location
            $includePaths = @(
              "external\zstd\zstd-v1.5.5\include",
              "build_deps\zlib\include",
              "build_deps\jsoncpp\include",
              "build_deps\jpeg\include",
              "external\HP-Socket-6.0.3\include",
              "external\clip-1.11\include",
              "external\ffmpeg\bin"
            ) | Where-Object { Test-Path $_ } | ForEach-Object { Join-Path $workspaceRoot $_ }

            $libPaths = @(
              "external\zstd\zstd-v1.5.5\lib",
              "build_deps\zlib\lib",
              "build_deps\jsoncpp\lib",
              "build_deps\jpeg\lib",
              "external\HP-Socket-6.0.3\lib",
              "external\clip-1.11\lib",
              "external\ffmpeg\bin"
            ) | Where-Object { Test-Path $_ } | ForEach-Object { Join-Path $workspaceRoot $_ }

            $includePathStr = $includePaths -join ";"
            $libPathStr = $libPaths -join ";"

            Write-Host "Include paths: $includePathStr"
            Write-Host "Library paths: $libPathStr"

            $msbuildArgs = @(
              $sln,
              "/m",
              "/p:Configuration=$env:CONFIGURATION",
              "/p:Platform=$env:MSBUILD_PLATFORM",
              "/p:PlatformToolset=v142",
              "/p:PreferredToolArchitecture=$env:MSBUILD_PLATFORM",
              "/p:AdditionalIncludeDirectories=""$includePathStr""",
              "/p:AdditionalLibraryDirectories=""$libPathStr"""
            )

            Write-Host "MSBuild arguments: $($msbuildArgs -join ' ')"
            & msbuild @msbuildArgs

            if ($LASTEXITCODE -ne 0) {
              throw "MSBuild failed with exit code: $LASTEXITCODE"
            }
            Write-Host "Build completed successfully"
          } catch {
            Write-Host "Build error: $($_.Exception.Message)"
            throw
          }

      - name: Collect artifacts
        run: |
          try {
            $outDir = "dist\${env:PLATFORM}\${env:CONFIGURATION}"
            Write-Host "Creating output directory: $outDir"
            if (!(Test-Path $outDir)) {
              New-Item -ItemType Directory -Force -Path $outDir | Out-Null
            }

            $patterns = @('*.exe','*.dll','*.pdb')
            Write-Host "Collecting artifacts with patterns: $($patterns -join ', ')"

            foreach ($pat in $patterns) {
              Write-Host "Searching for files matching: $pat"
              $files = Get-ChildItem -Recurse -File -Include $pat -Path . | Where-Object {
                $_.DirectoryName -match "\\(x64|x86|Win32)\\$env:CONFIGURATION(\\|$)"
              }

              Write-Host "Found $($files.Count) files matching $pat"
              foreach ($file in $files) {
                Write-Host "Copying: $($file.FullName)"
                try {
                  Copy-Item -Path $file.FullName -Destination $outDir -Force
                } catch {
                  Write-Host "Warning: Failed to copy $($file.FullName): $($_.Exception.Message)"
                }
              }
            }

            Write-Host "Collected artifacts:"
            $artifacts = Get-ChildItem -Path $outDir -ErrorAction SilentlyContinue
            if ($artifacts) {
              $artifacts | ForEach-Object {
                Write-Host "  $($_.FullName)"
              }
            } else {
              Write-Host "  No artifacts found in $outDir"
            }
          } catch {
            Write-Host "Error collecting artifacts: $($_.Exception.Message)"
            throw
          }

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-client-${{ matrix.platform }}-${{ matrix.configuration }}
          path: dist/${{ matrix.platform }}/${{ matrix.configuration }}
          retention-days: 7

  build-documentation:
    name: Build Documentation
    runs-on: self-hosted  # Ensure this only runs on your self-hosted Windows runner
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          clean: true
          token: ${{ secrets.GITHUB_TOKEN }}
        timeout-minutes: 10
        continue-on-error: false

      - name: Archive documentation
        uses: actions/upload-artifact@v4
        with:
          name: docs
          path: |
            ReadMe.md
            ReadMe_EN.md
            Dependencies.md
            history.md
            使用方法.txt
            使用花生壳.txt
            反向代理.md
          retention-days: 7
